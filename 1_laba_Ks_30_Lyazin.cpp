// Вариант 4
// Требуется написать программу, которая будет вычислять список простых чисел при помощи 
// алгоритма решета Эратосфена. Согласно этому алгоритму требуется сгенерировать последовательность
// чисел и пройдя по ней вычеркнуть из нее все не простые числа. 
// По итогу, нужно вывести последовательность простых чисел.

#include <iostream>

using namespace std;

void Add(int *array, int n);
void Eratosthene(int *array, int n);
void Print_Result(int *array, int n);


int main()
{	
	int n;
  	cout << "n  = ";
  	cin >> n;
  	n++;
  	int array[n];
  	
  	// Заполнение массива.
  	Add(array, n);
  	
  	// Обнуление непростых чисел.
  	Eratosthene(array, n);
    
    // Вывод.
	Print_Result(array, n);
	
  	return 0;
}


/*
 * Заполнение элементами массив
 *
 * @param ссылка на нужный массив.
 * @param n крайнее правое число.
 *
 * Циклично проходим от 0 до n и заполняем элементами массив.
 */
 
void Add(int *array, int n)
{
	// Последовательность от 0 до n включительно.
  	for (int i = 0; i < n; i++)
    	array[i] = i;
}


/*
 * Решето Эратосфера (обнуление составных чисел)
 *
 * @param ссылка на нужный массив.
 * @param n крайнее правое число.
 *
 * Циклично проходим от 2 до n (цикл i)
 * Циклично проходим от следующего элемента i через шаг i (2 * i) и обнуляем каждый элемент.
 * Отдельно обнуляем единицу (1 индекс) как не число не относящуеся к простым.
 */
 
void Eratosthene(int *array, int n)
{
	// Начиная со значения 2, обнуляем каждый i элемент, начиная со следующего.
    for (int i = 2; i < n; i++)
    {
    	for (int j = 2 * i; j < n; j += i)
    	{
    		array[j] = 0;
		}
	}
	
	// Отдельное обнуление единицы.
	array[1] = 0;
}


/*
 * Вывод результата
 *
 * @param ссылка на нужный массив.
 * @param n крайнее правое число.
 *
 * Циклично проходим от 0 до n (цикл i)
 * Выводим все ненулевые элементы
 */

void Print_Result(int *array, int n)
{
	for (int i = 0; i < n; i++)
	{
		if (array[i] != 0) cout << array[i] << endl;
	}
}

